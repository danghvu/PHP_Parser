%{
?><?php
/*
   +----------------------------------------------------------------------+
   | Based on the Zend Engine                                             |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2002 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        | 
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   | native PHP version:  Greg Beaver <cellog@users.sourceforge.net>      |
   | native PHP version:  Alan Knowles <alan@akbkhome.com>                |
   +----------------------------------------------------------------------+
*/

define('PHP_PARSER_EXTENDABLE_ERROR_PARSE', 1);

//
// This does nothing on it's own - refer to PHP_Parser
// It's purely the code for the Parser, generated by phpJay
//
 

class PHP_Parser_Extendable {

    /**
     * Options, used to control how the parser collects
     * and distributes the data it finds.
     *
     * Currently, options are grouped into two categories:
     * - containers for data
     * - publishing of data
     *
     * Default action is to return arrays of parsed data
     * for use by other applications.  The first set of
     * options, container options, provide a means to
     * tell the parser to encapsulate data in objects
     * instead of in arrays.  The option tells the parser which
     * class to instantiate for each documentable element.  The
     * default value of false will prompt the usage of arrays
     * instead.
     *
     * The second set of options provide for intermediary
     * publishing of data while parsing, to allow other
     * classes to hook into functionality if they desire
     * @var array
     * @access private
     */
    var $_options = array();
    
    /**
     * @var boolean
     */
    var $_get_class = false;
    
    /**
     * @access private
     */
    var $_grabDefine = false;
    /**
     * @access private
     */
    var $_inGlobal = false;
    
    /**
     * @see __construct
     */
    function PHP_Parser_Extendable($options = array())
    {
        $this->__construct($options);
    }
    
    /**
     * (syntax) error message.
     * Can be overwritten to control message format.
     * @param message text to be displayed.
     * @param expected vector of acceptable tokens, if available.
     */
    function raiseError ($message, $expected = null)
    {     
        if ($expected !== null ) {
            $m = "$message expecting";
            foreach($expected as $e) {
                $m .= " $e";
            }
        } else {
            $m = $message;
        }
        if ($expected === null) {
            $expected = array();
        }
        return PHP_Parser_Stack::staticPush('PHP_Parser_Extendable',
            PHP_PARSER_EXTENDABLE_ERROR_PARSE,
            'error', $expected,
            $message);  
    }

    /**
     * Set up options for parsing
     *
     * This class is designed to be extended, and so does not contain
     * any options
     * @see $_options
     */
    function __construct($options = array())
    {
        $this->_errors = PHP_Parser_Stack::singleton('PHP_Parser_Extendable');
    }

    /**
     * global variable name of parser arrays
     * should match the build options  
     *
     * @var string
     * @access private 
     */
    var $yyGlobalName = '_PHP_PARSER_EXTENDABLE';

    /**
     * Global Variable helper routine
     * @param string global variable name
     * @access private
     */
    function _initGlobal($name)
    {
        if ($this->yyLex->globalSearch($name)) {
            $lc = $this->yyLex->getLastComment();
            if ($this->_options['globalContainer']) {
                $container = $this->_options['globalContainer'];
                $global = new $container;
                $global->setStartLine($this->yyLex->line);
                $global->setName($name);
                $global->setDocumentation($lc[0]);
            } else {
                $global = array('name' => $name,
                                'documentation' => $lc[0],
                                'line' => $this->yyLex->line);
            }
            $this->globals[$name] = $global;
            $this->_inGlobal = true;
        } else {
            $this->_inGlobal = false;
        }
    }
    
    /**
     * Catenate tokens together
     *
     * This is here to allow extensibility of catenating basic tokens together.
     * A syntax highlighter could use this to higlight tokens before returning
     * them, or other operations can be performed
     * @param string $args... unlimited string arguments
     */
    function concat()
    {
        return implode(func_get_args(), ' ');
    }

    /**
     * Global Variable helper routine
     * @param string global variable name
     * @param string global variable initial value
     * @access private
     */
    function _processGlobal($name, $value)
    {
        if (isset($this->globals[$name])) {
            // found a global variable we are documenting
            if ($this->_options['globalContainer']) {
                $this->globals[$name]->setValue($value);
            } else {
                $this->globals[$name]['value'] = $value;
            }
            // publish the newly parsed global variable, if global variables should be published
            if ($this->_options['publisher'] && $this->_options['publishGlobals']) {
                $publish = $this->_options['publishMethod'];
                $message = 'method';
                if ($this->_options['publishGlobalMessage']) {
                    $message = $this->_options['publishGlobalMessage'];
                }
                if ($this->_options['publishMessageClass']) {
                    $pc = $this->_options['publishMessageClass'];
                    $publisher = $this->_options['publisher'];
                    $message = new $pc($message, $const);
                    $publisher->$publish($pc);
                } else {
                    $publisher = $this->_options['publisher'];
                    $publisher->$publish($message, $const);
                }
            }
        }
    }
    
    /**
     * For use with MsgServer
     * @param string ignored
     * @param object|array file-level documentation
     */
    function getFileDocs($messagetype, $message)
    {
        $this->documentation = $message;
    }
%}

%token T_INCLUDE 257
%token T_INCLUDE_ONCE 258
%token T_EVAL 259
%token T_REQUIRE 260
%token T_REQUIRE_ONCE 261
%token T_LOGICAL_OR 262
%token T_LOGICAL_XOR 263
%token T_LOGICAL_AND 264
%token T_PRINT 265
%token T_PLUS_EQUAL 266
%token T_MINUS_EQUAL 267
%token T_MUL_EQUAL 268
%token T_DIV_EQUAL 269
%token T_CONCAT_EQUAL 270
%token T_MOD_EQUAL 271
%token T_AND_EQUAL 272
%token T_OR_EQUAL 273
%token T_XOR_EQUAL 274
%token T_SL_EQUAL 275
%token T_SR_EQUAL 276
%token T_BOOLEAN_OR 277
%token T_BOOLEAN_AND 278
%token T_IS_EQUAL 279
%token T_IS_NOT_EQUAL 280
%token T_IS_IDENTICAL 281
%token T_IS_NOT_IDENTICAL 282
%token T_IS_SMALLER_OR_EQUAL 283
%token T_IS_GREATER_OR_EQUAL 284
%token T_SL 285
%token T_SR 286
%token T_INC 287
%token T_DEC 288
%token T_INT_CAST 289
%token T_DOUBLE_CAST 290
%token T_STRING_CAST 291
%token T_ARRAY_CAST 292
%token T_OBJECT_CAST 293
%token T_BOOL_CAST 294
%token T_UNSET_CAST 295
%token T_NEW 296
%token T_INSTANCEOF 297
%token T_EXIT 298
%token T_IF 299
%token T_ELSEIF 300
%token T_ELSE 301
%token T_ENDIF 302
%token T_LNUMBER 303
%token T_DNUMBER 304
%token T_STRING 305
%token T_STRING_VARNAME 306
%token T_VARIABLE 307
%token T_NUM_STRING 308
%token T_INLINE_HTML 309
%token T_CHARACTER 310
%token T_BAD_CHARACTER 311
%token T_ENCAPSED_AND_WHITESPACE 312
%token T_CONSTANT_ENCAPSED_STRING 313
%token T_ECHO 314
%token T_DO 315
%token T_WHILE 316
%token T_ENDWHILE 317
%token T_FOR 318
%token T_ENDFOR 319
%token T_FOREACH 320
%token T_ENDFOREACH 321
%token T_DECLARE 322
%token T_ENDDECLARE 323
%token T_AS 324
%token T_SWITCH 325
%token T_ENDSWITCH 326
%token T_CASE 327
%token T_DEFAULT 328
%token T_BREAK 329
%token T_CONTINUE 330
%token T_FUNCTION 331
%token T_CONST 332
%token T_RETURN 333
%token T_TRY 334
%token T_CATCH 335
%token T_THROW 336
%token T_USE 337
%token T_GLOBAL 338
%token T_STATIC 339
%token T_ABSTRACT 340
%token T_FINAL 341
%token T_PRIVATE 342
%token T_PROTECTED 343
%token T_PUBLIC 344
%token T_VAR 345
%token T_UNSET 346
%token T_ISSET 347
%token T_EMPTY 348
%token T_CLASS 349
%token T_INTERFACE 350
%token T_EXTENDS 351
%token T_IMPLEMENTS 352
%token T_OBJECT_OPERATOR 353
%token T_DOUBLE_ARROW 354
%token T_LIST 355
%token T_ARRAY 356
%token T_CLASS_C 357
%token T_FUNC_C 358
%token T_LINE 359
%token T_FILE 360
%token T_COMMENT 361
%token T_DOC_COMMENT 362
%token T_OPEN_TAG 363
%token T_OPEN_TAG_WITH_ECHO 364
%token T_CLOSE_TAG 365
%token T_WHITESPACE 366
%token T_START_HEREDOC 367
%token T_END_HEREDOC 368
%token T_DOLLAR_OPEN_CURLY_BRACES 369
%token T_CURLY_OPEN 370
%token T_PAAMAYIM_NEKUDOTAYIM 371
%token T_CLONE 372

%right T_STATIC T_ABSTRACT T_FINAL T_PRIVATE T_PROTECTED T_PUBLIC
%left T_ELSEIF
%left T_ELSE
%left T_ENDIF
%left T_INCLUDE T_INCLUDE_ONCE T_EVAL T_REQUIRE T_REQUIRE_ONCE
%left ','
%left T_LOGICAL_OR
%left T_LOGICAL_XOR
%left T_LOGICAL_AND
%right T_PRINT
%left '=' T_PLUS_EQUAL T_MINUS_EQUAL T_MUL_EQUAL T_DIV_EQUAL T_CONCAT_EQUAL T_MOD_EQUAL T_AND_EQUAL T_OR_EQUAL T_XOR_EQUAL T_SL_EQUAL T_SR_EQUAL
%left '?' ':'
%left T_BOOLEAN_OR
%left T_BOOLEAN_AND
%left '|'
%left '^'
%left '&'
%nonassoc T_IS_EQUAL T_IS_NOT_EQUAL T_IS_IDENTICAL T_IS_NOT_IDENTICAL
%nonassoc '<' T_IS_SMALLER_OR_EQUAL '>' T_IS_GREATER_OR_EQUAL
%left T_SL T_SR
%left '+' '-' '.'
%left '*' '/' '%'
%right '!' '~' T_INC T_DEC T_INT_CAST T_DOUBLE_CAST T_STRING_CAST T_ARRAY_CAST T_OBJECT_CAST T_BOOL_CAST T_UNSET_CAST '@'
%right '['
%nonassoc T_NEW T_INSTANCEOF T_CLONE

%start top_statement_list

%% /* Rules */

top_statement_list:
		top_statement_list  top_statement
	|	/* empty */
;

top_statement:
		statement
	|	function_declaration_statement	
	|	class_declaration_statement
;


inner_statement_list:
		inner_statement_list   inner_statement 
	|	/* empty */
;


inner_statement:
		statement
	|	function_declaration_statement
	|	class_declaration_statement
;


statement:
		unticked_statement 
;

unticked_statement:
		'{' inner_statement_list '}'
	|	T_IF '(' expr ')'  statement  elseif_list else_single 
	|	T_IF '(' expr ')' ':'  inner_statement_list  new_elseif_list new_else_single T_ENDIF ';' 
	|	T_WHILE '('  expr  ')'  while_statement 
	|	T_DO  statement T_WHILE '('  expr ')' ';' 
	|	T_FOR 
			'('
				for_expr
			';' 
				for_expr
			';' 
				for_expr
			')' 
			for_statement 
	|	T_SWITCH '(' expr ')'	 switch_case_list 
	|	T_BREAK ';'				
	|	T_BREAK expr ';'		
	|	T_CONTINUE ';'			
	|	T_CONTINUE expr ';'		
	|	T_RETURN ';'						
	|	T_RETURN expr_without_variable ';'
    {
        if (isset($this->returns)) {
            $this->returns[] = $2;
        }
    }
	|	T_RETURN variable ';'
    {
        if (isset($this->returns)) {
            $this->returns[] = $2;
        }
    }
	|	T_GLOBAL global_var_list ';'
	|	T_STATIC static_var_list ';'
	|	T_ECHO echo_expr_list ';'
	|	T_INLINE_HTML			
	|	expr ';'				
	|	T_USE use_filename ';'
	|	T_UNSET '(' unset_variables ')' ';'
	|	T_FOREACH '(' variable T_AS w_variable foreach_optional_arg ')' foreach_statement

	|	T_FOREACH '(' expr_without_variable T_AS  w_variable foreach_optional_arg ')'  foreach_statement 
	|	T_DECLARE  '(' declare_list ')' declare_statement 
	|	';'		/* empty statement */
	|	T_TRY  '{' inner_statement_list '}'
		T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
		additional_catches
    {
        if (isset($this->catches)) {
            $this->catches[] = $7;
        }
    }
	|	T_THROW
    {
        $this->_get_class = true;
    } expr ';'
    {
        $this->_get_class = false;
        if (isset($this->throws)) {
            $this->throws[] = $3;
        }
    }
;


additional_catches:
		non_empty_additional_catches
	|	/* empty */
;

non_empty_additional_catches:
		non_empty_additional_catches T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
    {
        if (isset($this->catches)) {
            $this->catches[] = $4;
        }
    }
	|	T_CATCH '(' fully_qualified_class_name T_VARIABLE ')'  '{' inner_statement_list '}' 
    {
        if (isset($this->catches)) {
            $this->catches[] = $3;
        }
    }
;


unset_variables:
		unset_variable
	|	unset_variables ',' unset_variable
;

unset_variable:
		variable	
;

use_filename:
		T_CONSTANT_ENCAPSED_STRING
    {
        $$ = $1;
    }
	|	'(' T_CONSTANT_ENCAPSED_STRING ')'
    {
        $$ = $2;
    }
;


function_declaration_statement:
		unticked_function_declaration_statement	
;

class_declaration_statement:
		unticked_class_declaration_statement	
;


is_reference:
		/* empty */
    {
        $$ = false;
    }
	|	'&'
    {
        $$ = true;
    }
;


unticked_function_declaration_statement:
		T_FUNCTION  is_reference T_STRING
    {
        $this->functionLine = $this->yyLex->line; 
        $this->functionPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->functionComment = $lc[0];
        $this->functionCommentToken = $this->yyLex->lastCommentToken;
        $this->params = array();
        $this->statics = array();
        $this->funcglobals = array();
        $this->superglobals = array();
        $this->returns = array();
        $this->throws = array();
        $this->catches = array();
        if ($this->_options['functionContainer']) {
            $container = $this->_options['functionContainer'];
            $this->functions[$3] = new $container;
            $this->functions[$3]->setReference($2);
        } else {
        }
    }
			'(' parameter_list ')'  '{' inner_statement_list '}'
    {
        if ($this->_options['functionContainer']) {
            $container = $this->_options['functionContainer'];
            $this->functions[$3] = new $container;
            $this->functions[$3]->setName($3);
            $this->functions[$3]->setReference($2);
            $this->functions[$3]->setParams($this->params);
            $this->functions[$3]->setGlobals($this->funcglobals);
            $this->functions[$3]->setSuperGlobals($this->superglobals);
            $this->functions[$3]->setStatics($this->statics);
            $this->functions[$3]->setThrows($this->throws);
            $this->functions[$3]->setCatches($this->throws);
            $this->functions[$3]->setDocumentation($this->functionComment);
            $this->functions[$3]->setStartLine($this->functionLine);
            $this->functions[$3]->setEndLine($this->yyLex->line);
        } else {
            $this->functions[$3] = array(
                'returnsReference' => $2,
                'params' => $this->params,
                'globals' => $this->funcglobals,
                'statics' => $this->statics,
                'returns' => $this->returns,
                'throws' => $this->throws,
                'catches' => $this->catches,
                'superglobals' => $this->superglobals,
                'startline' => $this->functionLine,
                'endline' => $this->yyLex->line,
                'documentation' => $this->functionComment,
                );
        }
        // publish the newly parsed function, if functions should be published
        if ($this->_options['publisher'] && $this->_options['publishFunctions']) {
            $publish = $this->_options['publishMethod'];
            $message = 'function';
            if ($this->_options['publishFunctionMessage']) {
                $message = $this->_options['publishFunctionMessage'];
            }
            if ($this->_options['publishMessageClass']) {
                $pc = $this->_options['publishMessageClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $this->functions[$3]);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $this->functions[$3]);
            }
        }
        unset($this->params);
        unset($this->returns);
        unset($this->statics);
        unset($this->funcglobals);
        unset($this->superglobals);
        unset($this->throws);
    }
;

unticked_class_declaration_statement:
    {
        $this->classLine = $this->yyLex->line; 
        $this->classPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->classComment = $lc[0];
        $this->classCommentToken = $this->yyLex->lastCommentToken;
    }	class_entry_type T_STRING extends_from
    {
        $this->methods = array();
        $this->vars = array();
        $this->consts = array();
        $this->implementsInterfaces = array();
    } 
			implements_list
			'{'
				class_statement_list
			'}'
    {
        if ($this->_options['classContainer']) {
            $container = $this->_options['classContainer'];
            $this->classes[$3] = new $container;
            $this->classes[$3]->setName($3);
            $this->classes[$3]->setExtends($4);
            $this->classes[$3]->setType($2);
            $this->classes[$3]->setMethods($this->methods);
            $this->classes[$3]->setVars($this->vars);
            $this->classes[$3]->setConsts($this->consts);
            $this->classes[$3]->setImplements($this->implementsInterfaces);
            $this->classes[$3]->setDocumentation($this->classComment);
            $this->classes[$3]->setStartLine($this->classLine);
            $this->classes[$3]->setEndLine($this->yyLex->line);
        } else {
            // use arrays if no class container is defined
            $this->classes[$3] = array(
                 'extends' => $4,
                 'type' => $2,
                 'methods' => $this->methods,
                 'vars' => $this->vars,
                 'consts' => $this->consts,
                 'implements' => $this->implementsInterfaces,
                 'startline' => $this->classLine,
                 'endline' => $this->yyLex->line,
                 'documentation' => $this->classComment,
                 );
        }
        // publish the newly parsed class, if classes should be published
        if ($this->_options['publisher'] && $this->_options['publishClasses']) {
            $publish = $this->_options['publishMethod'];
            $message = 'class';
            if ($this->_options['publishClassMessage']) {
                $message = $this->_options['publishClassMessage'];
            }
            if ($this->_options['publishMessageClass']) {
                $pc = $this->_options['publishMessageClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $this->classes[$3]);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $this->classes[$3]);
            }
        }
        unset($this->methods);
        unset($this->vars);
        unset($this->consts);
        unset($this->throws);
        unset($this->implementsInterfaces);
    }
;


class_entry_type:
		T_CLASS
    {
        $$ = '';
    }
	|	T_ABSTRACT T_CLASS
    {
        $$ = 'abstract';
    }
	|	T_FINAL T_CLASS
    {
        $$ = 'final';
    }
	|	T_INTERFACE
    {
        $$ = 'interface';
    }
;

extends_from:
		/* empty */
    {
        $$ = '';
    }
	|	T_EXTENDS fully_qualified_class_name
    {
        $$ = $2;
    }
;

implements_list:
		/* empty */
	|	T_IMPLEMENTS interface_list
;

interface_list:
		fully_qualified_class_name
    {
        if (isset($this->implementsInterfaces)) {
            $this->implementsInterfaces[] = $1;
        }
    }
	|	interface_list ',' fully_qualified_class_name
    {
        if (isset($this->implementsInterfaces)) {
            $this->implementsInterfaces[] = $3;
        }
    }
;

foreach_optional_arg:
		/* empty */				
	|	T_DOUBLE_ARROW w_variable
;

for_statement:
		statement
	|	':' inner_statement_list T_ENDFOR ';'
;


foreach_statement:
		statement
	|	':' inner_statement_list T_ENDFOREACH ';'
;


declare_statement:
		statement
	|	':' inner_statement_list T_ENDDECLARE ';'
;


declare_list:
		T_STRING '=' static_scalar					
	|	declare_list ',' T_STRING '=' static_scalar	
;


switch_case_list:
		'{' case_list '}'					
	|	'{' ';' case_list '}'				
	|	':' case_list T_ENDSWITCH ';'		
	|	':' ';' case_list T_ENDSWITCH ';'	
;


case_list:
		/* empty */	
	|	case_list T_CASE expr case_separator  inner_statement_list 
	|	case_list T_DEFAULT case_separator  inner_statement_list 
;


case_separator:
		':'
	|	';'
;


while_statement:
		statement
	|	':' inner_statement_list T_ENDWHILE ';'
;



elseif_list:
		/* empty */
	|	elseif_list T_ELSEIF '(' expr ')'  statement 
;


new_elseif_list:
		/* empty */
	|	new_elseif_list T_ELSEIF '(' expr ')' ':'  inner_statement_list 
;


else_single:
		/* empty */
	|	T_ELSE statement
;


new_else_single:
		/* empty */
	|	T_ELSE ':' inner_statement_list
;


parameter_list: 
		non_empty_parameter_list
	|	/* empty */
;


non_empty_parameter_list:
		optional_class_type T_VARIABLE
    {
        $this->params[$2] = array('default' => null, 'type' => $1, 'isReference' => false, 'const' => false);
    }
	|	optional_class_type '&' T_VARIABLE
    {
        $this->params[$3] = array('default' => null, 'type' => $1, 'isReference' => true, 'const' => false);
    }
	|	optional_class_type '&' T_VARIABLE '=' static_scalar
    {
        $this->params[$3] = array('default' => $5, 'type' => $1, 'isReference' => true, 'const' => false);
    }
	|	T_CONST optional_class_type T_VARIABLE
    {
        $this->params[$2] = array('default' => null, 'type' => $2, 'isReference' => false, 'const' => true);
    }
	|	optional_class_type T_VARIABLE '=' static_scalar
    {
        $this->params[$2] = array('default' => $4, 'type' => $1, 'isReference' => false, 'const' => false);
    }
	|	non_empty_parameter_list ',' optional_class_type T_VARIABLE
    {
        $this->params[$4] = array('default' => null, 'type' => $3, 'isReference' => false, 'const' => false);
    }
	|	non_empty_parameter_list ',' optional_class_type '&' T_VARIABLE
    {
        $this->params[$5] = array('default' => null, 'type' => $3, 'isReference' => true, 'const' => false);
    }
	|	non_empty_parameter_list ',' optional_class_type '&' T_VARIABLE	 '=' static_scalar
    {
        $this->params[$5] = array('default' => $7, 'type' => $3, 'isReference' => true, 'const' => false);
    }
	|	non_empty_parameter_list ',' T_CONST optional_class_type T_VARIABLE
    {
        $this->params[$5] = array('default' => null, 'type' => $4, 'isReference' => false, 'const' => true);
    }
	|	non_empty_parameter_list ',' optional_class_type T_VARIABLE '=' static_scalar
    {
        $this->params[$4] = array('default' => $6, 'type' => $3, 'isReference' => false, 'const' => false);
    }
;


optional_class_type:
		/* empty */		
    {
        $$ = '';
    }
	|	fully_qualified_class_name
    {
        $$ = $1;
    }
;


function_call_parameter_list:
		non_empty_function_call_parameter_list	|	/* empty */				
    {
        $$ = '';
    }
;


non_empty_function_call_parameter_list:
		expr_without_variable	
	|	variable				
	|	'&' w_variable 				
    {
        $$ = '&' . $2;
    }
	|	non_empty_function_call_parameter_list ',' expr_without_variable
    {
        if ($this->_grabDefine) {
            $this->defineName = $1;
            $this->defineValue = $3;
        }
        $$ = $1 . ', ' . $3;
    }
	|	non_empty_function_call_parameter_list ',' variable					
    {
        if ($this->_grabDefine) {
            $this->defineName = $1;
            $this->defineValue = $3;
        }
        $$ = $1 . ', ' . $3;
    }
	|	non_empty_function_call_parameter_list ',' '&' w_variable				
    {
        if ($this->_grabDefine) {
            $this->defineName = $1;
            $this->defineValue = '&' . $4;
        }
        $$ = $1 . ', &' . $4;
    }
;

global_var_list:
		global_var_list ',' global_var
	|	global_var
;


global_var:
		T_VARIABLE	
    {
        $this->funcglobals[] = $1;
    }
	|	'$' r_variable
    {
        $this->funcglobals[] = '$' . $1;
    }
	|	'$' '{' expr '}'
    {
        $this->funcglobals[] = '${' . $3 . '}';
    }
;


static_var_list:
		static_var_list ',' T_VARIABLE
    {
        $this->statics[] = array('name' => $3, 'default' => null);
    }
	|	static_var_list ',' T_VARIABLE '=' static_scalar
    {
        $this->statics[] = array('name' => $3, 'default' => $5);
    }
	|	T_VARIABLE
    {
        $this->statics[] = array('name' => $1, 'default' => null);
    }
	|	T_VARIABLE '=' static_scalar
    {
        $this->statics[] = array('name' => $1, 'default' => $3);
    }
;


class_statement_list:
		class_statement_list class_statement
	|	/* empty */
    {
        $$ = '';
    }
;


class_statement:
		variable_modifiers class_variable_declaration
    {
        foreach($2 as $var) {
            $is_static = false;
            if (in_array('static', $1)) {
                $is_static = true;
                $z = array_flip($1);
                unset($1[$z['static']]);
            }
            if ($this->_options['varContainer']) {
                $var->setAccess($1);
                if ($is_static) {
                    $var->setStatic();
                }
            } else {
                $var['access'] = $1;
                $var['static'] = $is_static;
            }
            $this->vars[] = $var;
            // publish the newly parsed var, if vars should be published
            if ($this->_options['publisher'] && $this->_options['publishVars']) {
                $publish = $this->_options['publishMethod'];
                $message = 'var';
                if ($this->_options['publishVarMessage']) {
                    $message = $this->_options['publishVarMessage'];
                }
                if ($this->_options['publishMessageClass']) {
                    $pc = $this->_options['publishMessageClass'];
                    $publisher = $this->_options['publisher'];
                    $message = new $pc($message, $var);
                    $publisher->$publish($pc);
                } else {
                    $publisher = $this->_options['publisher'];
                    $publisher->$publish($message, $var);
                }
            }
        }
    } ';'
	|	class_constant_declaration ';'
	|
    {
        $this->methodLine = $this->yyLex->line; 
        $this->methodPos = $this->yyLex->pos;
        $lc = $this->yyLex->getLastComment();
        $this->methodComment = $lc[0];
        $this->methodCommentToken = $this->yyLex->lastCommentToken;
    }
    method_modifiers T_FUNCTION is_reference T_STRING
    {
        $this->throws = array();
        $this->catches = array();
        $this->params = array();
        $this->returns = array();
        $this->referencedVars = array();
        $this->referencedClasses = array();
        $this->statics = array();
        $this->funcglobals = array();
        $this->superglobals = array();
    } '(' 
			parameter_list ')' method_body
    {
        $is_static = false;
        if (in_array('static', $2)) {
            $is_static = true;
            $z = array_flip($2);
            unset($2[$z['static']]);
        }
        if ($this->_options['methodContainer']) {
            $container = $this->_options['methodContainer'];
            $this->methods[$5] = new $container;
            $this->methods[$5]->setName($5);
            $this->methods[$5]->setReference($4);
            $this->methods[$5]->setParams($this->params);
            $this->methods[$5]->setReferencedVars($this->referencedVars);
            $this->methods[$5]->setReferencedClasses($this->referencedClasses);
            $this->methods[$5]->setGlobals($this->funcglobals);
            $this->methods[$5]->setSuperGlobals($this->superglobals);
            $this->methods[$5]->setStatics($this->statics);
            $this->methods[$5]->setThrows($this->throws);
            $this->methods[$5]->setCatches($this->catches);
            $this->methods[$5]->setStartLine($this->methodLine);
            $this->methods[$5]->setEndLine($this->yyLex->line);
            $this->methods[$5]->setDocumentation($this->methodComment);
            if ($is_static) {
                $this->methods[$5]->setStaticMethod();
            }
            $this->methods[$5]->setModifiers($2);
        } else {
            $this->methods[$5] = array(
                'modifiers' => $2,
                'static' => $is_static,
                'returnsReference' => $4,
                'params' => $this->params,
                'globals' => $this->funcglobals,
                'statics' => $this->statics,
                'throws' => $this->throws,
                'catches' => $this->catches,
                'referencedVars' => $this->referencedVars,
                'referencedClasses' => $this->referencedClasses,
                'returns' => $this->returns,
                'superglobals' => $this->superglobals,
                'startline' => $this->methodLine,
                'endline' => $this->yyLex->line,
                'documentation' => $this->methodComment,
                );
        }
        // publish the newly parsed method, if methods should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishMethodMessage']) {
                $message = $this->_options['publishMethodMessage'];
            }
            if ($this->_options['publishMessageClass']) {
                $pc = $this->_options['publishMessageClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $this->methods[$5]);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $this->methods[$5]);
            }
        }
        unset($this->returns);
        unset($this->referencedVars);
        unset($this->referencedClasses);
        unset($this->statics);
        unset($this->throws);
        unset($this->catches);
        unset($this->funcglobals);
        unset($this->superglobals);
    }
;


method_body:
		';' /* abstract method */		
	|	'{' inner_statement_list '}'	
;

variable_modifiers:
		non_empty_member_modifiers
    {
        $$ = $1;
    }
	|	T_VAR
    {
        $$ = array('public');
    }
;

method_modifiers:
		/* empty */
    {
        $$ = array('public');
    }
	|	non_empty_member_modifiers
    {
        $$ = $1;
    }
;

non_empty_member_modifiers:
		member_modifier
    {
        $$ = array($1);
    }
	|	non_empty_member_modifiers member_modifier
    {
        $$ = $1;
        $$[] = $2;
    }
;

member_modifier:
		T_PUBLIC
    {
        $$ = 'public';
    }
		|	T_PROTECTED
    {
        $$ = 'protected';
    }
   	|	T_PRIVATE
    {
        $$ = 'private';
    }
   	|	T_STATIC
    {
        $$ = 'static';
    }
   	|	T_ABSTRACT
    {
        $$ = 'abstract';
    }
   	|	T_FINAL
    {
        $$ = 'final';
    }
;

class_variable_declaration:
		class_variable_declaration ',' T_VARIABLE
    {
        $$ = $1;
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($3);
            $var->setStartLine($this->yyLex->line);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $$[] = $var;
        } else {
            $lc = $this->yyLex->getLastComment();
            $$[] = array('name' => $3,
                         'startline' => $this->_varLine,
                         'endline' => $this->yyLex->line,
                         'documentation' => $lc[0],
                         'default' => null);
        }
    }
	|	class_variable_declaration ','
     T_VARIABLE
    {
        $this->_varLine = $this->yyLex->line;
        
    } '=' static_scalar
    {
        $$ = $1;
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($3);
            $var->setStartLine($this->_varLine);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $var->setDefault($6);
            $$[] = $var;
        } else {
            $lc = $this->yyLex->getLastComment();
            $$[] = array('name' => $3,
                         'startline' => $this->yyLex->line,
                         'endline' => $this->yyLex->line,
                         'documentation' => $lc[0],
                         'default' => $6);
        }
    }
	|
    T_VARIABLE
    {
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($1);
            $var->setStartLine($this->yyLex->line);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $$ = array($var);
        } else {
            $lc = $this->yyLex->getLastComment();
            $$ = array(array('name' => $1,
                             'startline' => $this->yyLex->line,
                             'endline' => $this->yyLex->line,
                             'documentation' => $lc[0],
                             'default' => null));
        }
    }
	|
     T_VARIABLE {
        $this->_varLine = $this->yyLex->line;
    } '=' static_scalar
    {
        if ($this->_options['varContainer']) {
            $container = $this->_options['varContainer'];
            $var = new $container;
            $var->setName($1);
            $var->setStartLine($this->_varLine);
            $var->setEndLine($this->yyLex->line);
            $lc = $this->yyLex->getLastComment();
            $var->setDocumentation($lc[0]);
            $var->setDefault($4);
            $$ = array($var);
        } else {
            $lc = $this->yyLex->getLastComment();
            $$ = array(array('name' => $1,
                             'startline' => $this->_varLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $lc[0],
                             'default' => $4));
        }
    }
;

class_constant_declaration:
		class_constant_declaration ',' T_STRING
    {
        $lc = $this->yyLex->getLastComment();
        $this->constLine = $this->yyLex->line;
        $this->constComment = $lc[0];
    } '=' const_scalar_expr
    {
        if ($this->_options['classConstContainer']) {
            $container = $this->_options['classConstContainer'];
            $const = new $container;
            $const->setStartLine($this->constLine);
            $const->setEndLine($this->yyLex->line);
            $const->setDocumentation($this->constComment);
            $const->setValue($6);
            $const->setName($3);
        } else {
            $const = array('name' => $3,
                           'value' => $6,
                           'startline' => $this->constLine,
                           'endline' => $this->yyLex->line,
                           'documentation' => $this->constComment);
        }
        $this->consts[$4] = $const;
        // publish the newly parsed class constant, if class constants should be published
        if ($this->_options['publisher'] && $this->_options['publishClassConstants']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishClassConstantMessage']) {
                $message = $this->_options['publishClassConstantMessage'];
            }
            if ($this->_options['publishMessageClass']) {
                $pc = $this->_options['publishMessageClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $const);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $const);
            }
        }
    }
	|
    {
        $this->constLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->constComment = $lc[0];
    } T_CONST T_STRING '=' const_scalar_expr
    {
        if ($this->_options['classConstContainer']) {
            $container = $this->_options['classConstContainer'];
            $const = new $container;
            $const->setStartLine($this->constLine);
            $const->setEndLine($this->yyLex->line);
            $const->setDocumentation($this->constComment);
            $const->setValue($5);
            $const->setName($3);
        } else {
            $const = array('name' => $3,
                           'value' => $5,
                           'startline' => $this->constLine,
                           'endline' => $this->yyLex->line,
                           'documentation' => $this->constComment);
        }
        $this->consts[$3] = $const;
        // publish the newly parsed class constant, if class constants should be published
        if ($this->_options['publisher'] && $this->_options['publishClassConstants']) {
            $publish = $this->_options['publishMethod'];
            $message = 'method';
            if ($this->_options['publishClassConstantMessage']) {
                $message = $this->_options['publishClassConstantMessage'];
            }
            if ($this->_options['publishMessageClass']) {
                $pc = $this->_options['publishMessageClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $const);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $const);
            }
        }
    }
;

echo_expr_list:	
		echo_expr_list ',' expr 
	|	expr					
;


for_expr:
		/* empty */			
	|	non_empty_for_expr
;

non_empty_for_expr:
		non_empty_for_expr ','	 expr 
	|	expr
;

expr_without_variable:	
		T_LIST '('  assignment_list ')' '=' expr
    {
        $$ = $this->concat($1, $2, $3, $4, $5, $6);//'list(' . $3 . ') = ' . $6;
    }
	|	variable '='
    {
        $this->_initGlobal($1);
    } expr
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, $4);
        }
        $$ = $this->concat($1, $2, $4);//$1 . ' = '. $4;
    }
	|	variable '=' '&'
    {
        $this->_initGlobal($1);
    } variable
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, '&' .$5);
        }
        $$ = $this->concat($1, $2, $3, $5);//$1 .' =& '.$5;
    }
	|	variable
     '=' '&' T_NEW
    {
        $this->_initGlobal($1);
    } class_name_reference  ctor_arguments 
    {
        if ($this->_inGlobal) {
            $this->_processGlobal($1, '&new ' . $6 . $7);
        } else {
            if (isset($this->referencedClasses)) {
                $this->referencedClasses[] = $6;
            }
        }
        if ($this->_get_class) {
            $$ = $6;
        } else {
            $$ = $this->concat($1, $2, $3, $4, $6, $7);//$1 .' =& new '. $6 . $7;
        }
    }
	|	T_NEW class_name_reference  ctor_arguments
    {
        if (isset($this->referencedClasses)) {
            $this->referencedClasses[] = $2;
        }
        if ($this->_get_class) {
            $$ = $2;
        } else {
            $$ = $this->concat($1, $2, $3);//'new '.$2 . $3;
        }
    }
    |   T_CLONE expr
    {
        $$ = $2;
    }
	|	variable T_PLUS_EQUAL expr
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' += '.$3;
    }
	|	variable T_MINUS_EQUAL expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' -= '.$3;
    }
	|	variable T_MUL_EQUAL expr		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' *= '.$3;
    }
	|	variable T_DIV_EQUAL expr		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' /= '.$3;
    }
	|	variable T_CONCAT_EQUAL expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' .= '.$3;
    }
	|	variable T_MOD_EQUAL expr		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' %= '.$3;
    }
	|	variable T_AND_EQUAL expr		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' &= '.$3;
    }
	|	variable T_OR_EQUAL expr 		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' |= '.$3;
    }
	|	variable T_XOR_EQUAL expr 		
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' ^= '.$3;
    }
	|	variable T_SL_EQUAL expr	 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' <<= '.$3;
    }
	|	variable T_SR_EQUAL expr	 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' >>= '.$3;
    }
	|	rw_variable T_INC 
    {
        $$ = $this->concat($1, $2);//$1 . '++';
    }
	|	T_INC rw_variable 
    {
        $$ = $this->concat($1, $2);//'++' . $2;
    }
	|	rw_variable T_DEC 
    {
        $$ = $this->concat($1, $2);//$1 . '--';
    }
	|	T_DEC rw_variable 
    {
        $$ = $this->concat($1, $2);//'--' . $2;
    }
	|	expr T_BOOLEAN_OR  expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' || ' . $3;
    }
	|	expr T_BOOLEAN_AND  expr   
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' && ' . $3;
    }
	|	expr T_LOGICAL_OR  expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' or ' . $3;
    }
	|	expr T_LOGICAL_AND  expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' and ' . $3;
    }
	|	expr T_LOGICAL_XOR expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' xor ' . $3;
    }
	|	expr '|' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' | '.$3;
    }
	|	expr '&' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' & '.$3;
    }
	|	expr '^' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' ^ '.$3;
    }
	|	expr '.' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' . '.$3;
    }
	|	expr '+' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' + '.$3;
    }
	|	expr '-' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' - '.$3;
    }
	|	expr '*' expr
    {
        $$ = $this->concat($1, $2, $3);//$1 .' * '.$3;
    }
	|	expr '/' expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 .' / '.$3;
    }
	|	expr '%' expr 	
    {
        $$ = $this->concat($1, $2, $3);//$1 .' % '.$3;
    }
	| 	expr T_SL expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 .' << '.$3;
    }
	|	expr T_SR expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 .' >> '.$3;
    }
	|	'+' expr 
    {
        $$ = $this->concat($1, $2);//' + ' . $2;
    }
	|	'-' expr 
    {
        $$ = $this->concat($1, $2);//' - ' . $2;
    }
	|	'!' expr 
    {
        $$ = $this->concat($1, $2);//'!' . $2;
    }
	|	'~' expr 
    {
        $$ = $this->concat($1, $2);//'~' . $2;
    }
	|	expr T_IS_IDENTICAL expr		
    {
        $$ = $this->concat($1, $2, $3);//$1 .' === '.$3;
    }
	|	expr T_IS_NOT_IDENTICAL expr	
    {
        $$ = $this->concat($1, $2, $3);//$1 .' !== '.$3;
    }
	|	expr T_IS_EQUAL expr			
    {
        $$ = $this->concat($1, $2, $3);//$1 .' == '.$3;
    }
	|	expr T_IS_NOT_EQUAL expr 		
    {
        $$ = $this->concat($1, $2, $3);//$1 . $2 . $3;
    }
	|	expr '<' expr 					
    {
        $$ = $this->concat($1, $2, $3);//$1 .' < '.$3;
    }
	|	expr T_IS_SMALLER_OR_EQUAL expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 .' <= '.$3;
    }
	|	expr '>' expr 					
    {
        $$ = $this->concat($1, $2, $3);//$1 .' > '.$3;
    }
	|	expr T_IS_GREATER_OR_EQUAL expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 .' >= '.$3;
    }
	|	expr T_INSTANCEOF class_name_reference 
    {
        $$ = $this->concat($1, $2, $3);//$1 .' instanceof '.$3;
    }
	|	'(' expr ')'
    {
        if ($this->_get_class) {
            $$ = $2;
        } else {
            $$ = $this->concat($1, $2, $3);//'(' . $2 . ')';
        }
    }
	|	expr '?' 
		expr ':' 
		expr
    {
        $$ = $this->concat($1, $2, $3, $4, $5);//$1 . ' ? ' . $3 .' : '. $5;
    }
	|	internal_functions_in_yacc
	|	T_INT_CAST expr
    {
        $$ = $this->concat($1, $2);//'(int) ' . $2;
    }
	|	T_DOUBLE_CAST expr 	
    {
        $$ = $this->concat($1, $2);//'(double) ' . $2;
    }
	|	T_STRING_CAST expr	 
    {
        $$ = $this->concat($1, $2);//'(string) ' . $2;
    }
	|	T_ARRAY_CAST expr 	
    {
        $$ = $this->concat($1, $2);//'(array) ' . $2;
    }
	|	T_OBJECT_CAST expr 	
    {
        $$ = $this->concat($1, $2);//'(object) ' . $2;
    }
	|	T_BOOL_CAST expr	
    {
        $$ = $this->concat($1, $2);//'(bool) ' . $2;
    }
	|	T_UNSET_CAST expr	
    {
        $$ = $this->concat($1, $2);//'(unset) ' . $2;
    }
	|	T_EXIT exit_expr
    {
        $$ = $this->concat($1, $2);//$1 . $2;
    }
	|	'@'  expr
    {
        $$ = $this->concat($1, $2);//'@' . $2;
    }
	|	scalar
    {
        $$ = $1;
    }
	|	T_ARRAY '(' array_pair_list ')'
    {
        $$ = $this->concat($1, $2, $3, $4);
    }
	|	'`' encaps_list '`'
    {
        $$ = $this->concat($1 . $2 . $3);
    }
	|	T_PRINT expr
    {
        $$ = $this->concat($1 . $2);
    }
;

function_call:
		T_STRING
    {
        if (strtolower($1) == 'define') {
            $this->defineLine = $this->yyLex->line;
            $lc = $this->yyLex->getLastComment();
            $this->defineComment = $lc[0];
            $this->_grabDefine = true;
            $this->defineName = '';
            $this->defineValue = '';
        }
    } '(' function_call_parameter_list ')'
    {
        if ($this->_grabDefine && !empty($this->defineName)) {
            if ($this->_options['constContainer']) {
                $container = $this->_options['constContainer'];
                $const = new $container;
                $const->setStartLine($this->defineLine);
                $const->setEndLine($this->yyLex->line);
                $const->setDocumentation($this->defineComment);
                $const->setValue($this->defineValue);
                $const->setName($this->defineName);
            } else {
                $const = array('name' => $this->defineName,
                               'value' => $this->defineValue,
                               'startline' => $this->defineLine,
                               'endline' => $this->yyLex->line,
                               'documentation' => $this->defineComment);
            }
            $this->constants[$this->defineName] = $const;
            // publish the newly parsed class constant, if class constants should be published
            if ($this->_options['publisher'] && $this->_options['publishConstants']) {
                $publish = $this->_options['publishMethod'];
                $message = 'method';
                if ($this->_options['publishConstantMessage']) {
                    $message = $this->_options['publishConstantMessage'];
                }
                if ($this->_options['publishMessageClass']) {
                    $pc = $this->_options['publishMessageClass'];
                    $publisher = $this->_options['publisher'];
                    $message = new $pc($message, $const);
                    $publisher->$publish($pc);
                } else {
                    $publisher = $this->_options['publisher'];
                    $publisher->$publish($message, $const);
                }
            }
        }
        $this->_grabDefine = false;
        $$ = $this->concat($1, $3, $4, $5);
    }
	|	class_constant '(' function_call_parameter_list ')'
    {
        $$ = $this->concat($1, $2, $3, $4);
    }
	|	variable_without_objects  '(' 
			function_call_parameter_list ')'
	{
        $$ = $this->concat($1, $2, $3, $4);
    }
;

fully_qualified_class_name:
		T_STRING 
;

class_name_reference:
		T_STRING				
	|	dynamic_class_name_reference	
;


dynamic_class_name_reference:
		base_variable T_OBJECT_OPERATOR 
			object_property  dynamic_class_name_variable_properties
	{
        echo 'here';
        if (isset($this->referencedVars)) {
            $this->referencedVars[] = $this->concat($1, $2, $3, $4);
        }
    }
	|	base_variable
    {
        if (isset($this->referencedVars)) {
            $this->referencedVars[] = $1;
        }
        $$ = $1;
    }
;


dynamic_class_name_variable_properties:
		dynamic_class_name_variable_properties dynamic_class_name_variable_property
	|	/* empty */
;


dynamic_class_name_variable_property:
		T_OBJECT_OPERATOR object_property 
;

exit_expr:
		/* empty */		
    {
        $$ = '';
    }
	|	'(' ')'			
    {
        $$ = '()';
    }
	|	'(' expr ')'	
    {
        $$ = $this->concat('(', $2, ')');
    }
;


ctor_arguments:
		/* empty */	
    {
        $$ = '';
    }
	|	'(' function_call_parameter_list ')'
    {
        $$ = '(' . $2 . ')';
    }
;


common_scalar:
		T_LNUMBER
	|	T_DNUMBER
	|	T_CONSTANT_ENCAPSED_STRING
	|	T_LINE
	|	T_FILE
	|	T_CLASS_C
	|	T_FUNC_C
;


const_scalar_expr: /* compile-time evaluated scalar expressions */
		const_scalar
	|   const_scalar_expr_list
;

const_scalar_expr_list:
		const_scalar_expr T_SL const_scalar_expr
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' << ' . $3;
    }
	|	const_scalar_expr T_SR const_scalar_expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' >> ' . $3;
    }
	|	const_scalar_expr T_LOGICAL_XOR  const_scalar_expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' xor ' . $3;
    }
	|   const_scalar_expr '|'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' | ' . $3;
    }
	|   const_scalar_expr '&'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' & ' . $3;
    }
	|   const_scalar_expr '^'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' ^ ' . $3;
    }
	|	const_scalar_expr '.'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' . ' . $3;
    }
	|   const_scalar_expr '+'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' + ' . $3;
    }
	|   const_scalar_expr '-'  const_scalar_expr 
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' - ' . $3;
    }
	|   const_scalar_expr '*'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' * ' . $3;
    }
	|   const_scalar_expr '/'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' / ' . $3;
    }
	|   const_scalar_expr '%'  const_scalar_expr  
    {
        $$ = $this->concat($1, $2, $3);//$1 . ' % ' . $3;
    }
	|                     '~'  const_scalar_expr 
    {
        $$ = $this->concat($1, $2);//'~' . $1;
    }
	|   '(' const_scalar_expr ')'
    {
        $$ = $this->concat($1, $2, $3);//'(' . $2 . ')';
    }
;

const_scalar:
		common_scalar
	|	T_STRING
	|	'+' const_scalar
    {
        $$ = $this->concat($1, $2);//'+' . $2;
    }
	|	'-' const_scalar
    {
        $$ = $this->concat($1, $2);//'-' . $2;
    }
	|	T_ARRAY '(' static_array_pair_list ')'
    {
        $$ = $this->concat($1, $2, $3, $4);//'array(' . $3 . ')';
    }
	|	static_class_constant
;

static_scalar: /* compile-time evaluated scalars */
		common_scalar
	|	T_STRING
	|	'+' static_scalar
    {
        $$ = '+' . $2;
    }
	|	'-' static_scalar
    {
        $$ = '-' . $2;
    } 
	|	T_ARRAY '(' static_array_pair_list ')'
    {
        $$ = 'array(' . $3 . ')';
    }
	|	static_class_constant
;

static_class_constant:
		T_STRING T_PAAMAYIM_NEKUDOTAYIM T_STRING
    {
        $$ = $this->concat($1, $2, $3);//$1 . '::' . $3;
    }
;

scalar:
		T_STRING
	|	T_STRING_VARNAME
	|	class_constant
	|	common_scalar
	|	'"' encaps_list '"'
    {
        $$ = '"' . $2 . '"';
    }
	|	'\'' encaps_list '\''
    {
        $$ = "'" . $2 . "'";
    }
	|	T_START_HEREDOC encaps_list T_END_HEREDOC
    {
        $$ = $2;
    }
;


static_array_pair_list:
		/* empty */
    {
        $$ = '';
    }
	|	non_empty_static_array_pair_list possible_comma
    {
        $$ = $1 . $2;
    }
;

possible_comma:
		/* empty */
    {
        $$ = '';
    }
	|	','
    {
        $$ = ', ';
    }
;

non_empty_static_array_pair_list:
		non_empty_static_array_pair_list ',' static_scalar T_DOUBLE_ARROW static_scalar
    {
        $$ = $1 . ",\n" . $3 . ' => ' . $5;
    }
	|	non_empty_static_array_pair_list ',' static_scalar
    {
        $$ = $1 . ",\n" . $3;
    }
	|	static_scalar T_DOUBLE_ARROW static_scalar
    {
        $$ = $1 . ' => '. $3;
    }
	|	static_scalar 
;

expr:
		r_variable
	|	expr_without_variable
;


r_variable:
	variable
;


w_variable:
	variable
;

rw_variable:
	variable
;

variable:
		base_variable_with_function_calls T_OBJECT_OPERATOR object_property method_or_not variable_properties
    {
        if (isset($this->referencedVars)) {
            if ($1 == '$this' && !$4) {
                $this->referencedVars[] = $3;
            }
        }
        $$ = $1 . $2 . $3 . $4 . $5;
    }
	|	base_variable_with_function_calls
    {
        $$ = $1;
    }
;

variable_properties:
		variable_properties variable_property
    {
        $$ = $1 . $2;
    }
	|	/* empty */ 
;


variable_property:
		T_OBJECT_OPERATOR object_property  method_or_not
    {
        $$ = $1 . $2 . $3;
    }
;

method_or_not:
		'(' 
				function_call_parameter_list ')' 
    {
        $$ = $1 . $2 . $3;
    }
	|	/* empty */ 
    {
        $$ = false;
    }
;

variable_without_objects:
		reference_variable
	|	simple_indirect_reference reference_variable 
    {
        $$ = $1 . $2;
    }
;

static_member:
		fully_qualified_class_name T_PAAMAYIM_NEKUDOTAYIM variable_without_objects
    {
        $$ = $1 . '::' . $3;
    }
;


base_variable_with_function_calls:
		base_variable
	|	function_call
;


base_variable:
		reference_variable
	|	simple_indirect_reference reference_variable
    {
        $$ = $1 . $2;
    }
	|	static_member
;
	
reference_variable:
		reference_variable '[' dim_offset ']'
    {
        if (isset($this->superglobals)) {
            if ($1 == '$GLOBALS' ||
                $1 == '$_SERVER' ||
                $1 == '$_REQUEST' ||
                $1 == '$_ENV' ||
                $1 == '$_GET' ||
                $1 == '$_POST' ||
                $1 == '$_COOKIE' ||
                $1 == '$_FILES' ||
                $1 == '$_SESSION') {
                $this->_get_var = false;
                $this->superglobals[] = array('array' => $1,
                                              'var' => $3);
            }
        } else {
            if ($1 == '$GLOBALS' ||
                $1 == '$_SERVER' ||
                $1 == '$_REQUEST' ||
                $1 == '$_ENV' ||
                $1 == '$_GET' ||
                $1 == '$_POST' ||
                $1 == '$_COOKIE' ||
                $1 == '$_FILES' ||
                $1 == '$_SESSION') {
                $this->_get_var = false;
                $this->filesuperglobals[] = array('array' => $1,
                                              'var' => $3);
            }
        }
        $$ = $1 . '[' . $3 . ']';
    }
	|	reference_variable '{' expr '}'
    {
        $$ = $1 . '{' . $3 . '}';
    }
	|	compound_variable			
;
	

compound_variable:
		T_VARIABLE
	|	'$' '{' expr '}'
    {
        $$ = '${' . $3 . '}';
    }
;

dim_offset:
		/* empty */		
    {
        $$ = '';
    }
	|	expr
;


object_property:
		object_dim_list
	|	variable_without_objects 
;

object_dim_list:
		object_dim_list '[' dim_offset ']'	
    {
        $$ = $1 . $2 . $3 . $4;
    }
	|	object_dim_list '{' expr '}'		
    {
        $$ = $1 . $2 . $3 . $4;
    }
	|	variable_name
    {
        $$ = $1;
    }
;

variable_name:
		T_STRING		
    {
        $$ = $1;
    }
	|	'{' expr '}'	
    {
        $$ = $2;
    }
;

simple_indirect_reference:
		'$' 
	|	simple_indirect_reference '$'
    {
        $$ = $1 . '$';
    }
;

assignment_list:
		assignment_list ',' assignment_list_element
	|	assignment_list_element
;


assignment_list_element:
		variable								
	|	T_LIST '('  assignment_list ')'	
	|	/* empty */							
;


array_pair_list:
		/* empty */ 
	|	non_empty_array_pair_list possible_comma
    {
        $$ = $1;
    }
;

non_empty_array_pair_list:
		non_empty_array_pair_list ',' expr T_DOUBLE_ARROW expr
    {
        $$ = $1 . ",\n" . $3 . ' => '. $5;
    }
	|	non_empty_array_pair_list ',' expr
    {
        $$ = $1 . ",\n" . $3;
    }
	|	expr T_DOUBLE_ARROW expr
    {
        $$ = $1 .' => '.$3;
    }
	|	expr 				
	|	non_empty_array_pair_list ',' expr T_DOUBLE_ARROW '&' w_variable 
    {
        $$ = $1 . ",\n" . $3 . ' => &' . $6;
    }
	|	non_empty_array_pair_list ',' '&' w_variable 
    {
        $$ = $1 . ",\n&" . $4;
    }
	|	expr T_DOUBLE_ARROW '&' w_variable	
    {
        $$ = $1 . ' => &' . $4;
    }
	|	'&' w_variable
    {
        $$ = '&' . $2;
    }
;

encaps_list:
		encaps_list encaps_var
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_STRING			
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_NUM_STRING		
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_ENCAPSED_AND_WHITESPACE	
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_CHARACTER 		
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_BAD_CHARACTER		
    {
        $$ = $1 . $2;
    }
	|	encaps_list '['		
    {
        $$ = $1 . $2;
    }
	|	encaps_list ']'		
    {
        $$ = $1 . $2;
    }
	|	encaps_list '{'		
    {
        $$ = $1 . $2;
    }
	|	encaps_list '}'		
    {
        $$ = $1 . $2;
    }
	|	encaps_list T_OBJECT_OPERATOR  
    {
        $$ = $1 . $2;
    }
	|	/* empty */			
    {
        $$ = '';
    }
;



encaps_var:
		T_VARIABLE 
	|	T_VARIABLE '['  encaps_var_offset ']'	
    {
        $$ = $1 . '[' . $3 . ']';
    }
	|	T_VARIABLE T_OBJECT_OPERATOR T_STRING
    {
        $$ = $1 . $2 . $3;
    }
	|	T_DOLLAR_OPEN_CURLY_BRACES expr '}' 
    {
        $$ = $1 . $2 . '}';
    }
	|	T_DOLLAR_OPEN_CURLY_BRACES T_STRING_VARNAME '[' expr ']' '}' 
    {
        $$ = $1 . $2 . '[' . $4 . ']}';
    }
	|	T_CURLY_OPEN variable '}'
    {
        $$ = $1 . $2 . '}';
    }
;


encaps_var_offset:
		T_STRING
	|	T_NUM_STRING
	|	T_VARIABLE
;


internal_functions_in_yacc:
		T_ISSET '(' isset_variables ')'
    {
        $$ = 'isset(' . $3 . ')';
    }
	|	T_EMPTY '(' variable ')'	
    {
        $$ = 'empty(' . $3 . ')';
    }
	|
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_INCLUDE expr
    {
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setFile($3);
            $include->setType('include');
            $include->setStartLine($this->includeLine);
            $include->setEndLine($this->yyLex->line);
            $include->setDocumentation($this->includeComment);
        } else {
            $include = array('file' => $3,
                             'type' => 'include',
                             'startline' => $this->includeLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $this->includeComment);
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            if ($this->_options['publishIncludeClass']) {
                $pc = $this->_options['publishIncludeClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $include);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $include);
            }
        }
    }
	|
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_INCLUDE_ONCE expr 	
    {
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setFile($3);
            $include->setType('include_once');
            $include->setStartLine($this->includeLine);
            $include->setEndLine($this->yyLex->line);
            $include->setDocumentation($this->includeComment);
        } else {
            $include = array('file' => $3,
                             'type' => 'include_once',
                             'startline' => $this->includeLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $this->includeComment);
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            if ($this->_options['publishIncludeClass']) {
                $pc = $this->_options['publishIncludeClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $include);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $include);
            }
        }
    }
	|	T_EVAL '(' expr ')' 	
	|
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_REQUIRE expr			
    {
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setFile($3);
            $include->setType('require');
            $include->setStartLine($this->includeLine);
            $include->setEndLine($this->yyLex->line);
            $include->setDocumentation($this->includeComment);
        } else {
            $include = array('file' => $3,
                             'type' => 'require',
                             'startline' => $this->includeLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $this->includeComment);
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            if ($this->_options['publishIncludeClass']) {
                $pc = $this->_options['publishIncludeClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $include);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $include);
            }
        }
    }
	|
    {
        $this->includeLine = $this->yyLex->line;
        $lc = $this->yyLex->getLastComment();
        $this->includeComment = $lc[0];
    } T_REQUIRE_ONCE expr		
    {
        if ($this->_options['includeContainer']) {
            $container = $this->_options['includeContainer'];
            $include = new $container;
            $include->setFile($3);
            $include->setType('require_once');
            $include->setStartLine($this->includeLine);
            $include->setEndLine($this->yyLex->line);
            $include->setDocumentation($this->includeComment);
        } else {
            $include = array('file' => $3,
                             'type' => 'require_once',
                             'startline' => $this->includeLine,
                             'endline' => $this->yyLex->line,
                             'documentation' => $this->includeComment);
        }
        $this->includes[] = $include;
        // publish the newly parsed include, if includes should be published
        if ($this->_options['publisher'] && $this->_options['publishMethods']) {
            $publish = $this->_options['publishMethod'];
            $message = 'include';
            if ($this->_options['publishIncludeMessage']) {
                $message = $this->_options['publishIncludeMessage'];
            }
            if ($this->_options['publishIncludeClass']) {
                $pc = $this->_options['publishIncludeClass'];
                $publisher = $this->_options['publisher'];
                $message = new $pc($message, $include);
                $publisher->$publish($pc);
            } else {
                $publisher = $this->_options['publisher'];
                $publisher->$publish($message, $include);
            }
        }
    }
;

isset_variables:
		variable 				
	|	isset_variables ','  variable 
;	

class_constant:
		fully_qualified_class_name T_PAAMAYIM_NEKUDOTAYIM T_STRING
        {
            $$ = $1 . '::' . $2;
        }
;

%%
}
